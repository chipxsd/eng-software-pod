;-------------------------------------------------------------------------------
; dabort.asm
;
; (c) Texas Instruments 2009-2013, All rights reserved.
;
;Cortex-R4 and Cortex-R4F Technical Reference Manual	Revision: r1p3
;Home > Programmer’s Model > Exceptions > Aborts
;2.8.4. Aborts
;
;When the processor's memory system cannot complete a memory access successfully, an abort is generated.
;Aborts can occur for a number of reasons, for example:
;    a permission fault indicated by the MPU
;    an error response to a transaction on the AXI memory bus
;    an error detected in the data by the ECC checking logic.

;An error occurring on an instruction fetch generates a prefetch abort.
;Errors occurring on data accesses generate data aborts. Aborts are also categorized as being either precise or imprecise.

;When a prefetch or data abort occurs, the processor takes the appropriate type of exception.
;See Exception entry and exit summary for more information. Additional information about the type of abort is stored in registers, and signaled as events.
;See Fault handling for more details of the types of fault that can cause an abort and the information that the processor provides about these faults.


;Prefetch aborts
;--------------------------------
;When a Prefetch Abort (PABT) occurs, the processor marks the prefetched instruction as invalid,
;but does not take the exception until the instruction is to be executed. If the instruction is not executed, for example because a
;branch occurs while it is in the pipeline, the abort does not take place.
;All prefetch aborts are precise.


;Data aborts
;--------------------------------
;An error occurring on a data memory access can generate a data abort. If the instruction generating the memory access is not executed,
;for example, because it fails its condition codes, or is interrupted, the data abort does not take place.
;A Data Abort (DABT) can be either precise or imprecise, depending on the type of fault that caused it.
;The processor implements the base restored Data Abort model, as opposed to a base updated Data Abort model.
;With the base restored Data Abort model, when a Data Abort exception occurs during the execution of a memory access instruction,
;the processor hardware always restores the base register to the value it contained before the instruction was executed. This removes the
;requirement for the Data Abort handler to unwind any base register update that the aborted instruction might have specified.
;This simplifies the software Data Abort handler. For more information, see the ARM Architecture Reference Manual.


;Precise aborts
;-----------------------------------
;A precise abort, also known as a synchronous abort, is one for which the exception is guaranteed to be taken on the instruction that
;generated the aborting memory access. The abort handler can use the value in the Link Register (r14_abt) to determine which instruction generated the abort,
;and the value in the Saved Program Status Register (SPSR_abt) to determine the state of the processor when the abort occurred.


;Imprecise aborts
;----------------------------------
;An imprecise abort, also known as an asynchronous abort, is one for which the exception is taken on a later instruction to the instruction that
;generated the aborting memory access. The abort handler cannot determine which instruction generated the abort, or the state of the processor when
;the abort occurred. Therefore, imprecise aborts are normally fatal.
;Imprecise aborts can be generated by store instructions to normal-type or device-type memory. When the store instruction is committed, the
;data is normally written into a buffer that holds the data until the memory system has sufficient bandwidth to perform the write access. This gives read
;accesses higher priority. The write data can be held in the buffer for a long period, during which many other instructions can complete.
;If an error occurs when the write is finally performed, this generates an imprecise abort.


;Imprecise abort masking
;---------------------------------
;The nature of imprecise aborts means that they can occur while the processor is handling a different abort. If an imprecise abort generates a
;new exception in such a situation, the r14_abt and SPSR_abt values are overwritten. If this occurs before the data is pushed to the stack in memory,
;the state information about the first abort is lost. To prevent this from happening, the CPSR contains a mask bit to indicate that an imprecise abort
;cannot be accepted, the A-bit. When the A-bit is set, any imprecise abort that occurs is held pending by the processor until the A-bit is cleared,
;when the exception is actually taken. The A-bit is automatically set when abort, IRQ or FIQ exceptions are taken, and on reset. You must only clear the
;A-bit in an abort handler after the state information has either been stacked to memory, or is no longer required.

;Only one pending imprecise abort of each imprecise abort type is supported.
;The processor supports the following pending imprecise aborts:
;    Imprecise external abort
;    If a subsequent imprecise external abort is signaled while another one is pending, the later one is ignored and only one abort is taken.
;    One TCM write external error for each TCM port.
;    Cache write parity or ECC error.

;If a subsequent cache parity or ECC error is signaled while another one is pending, the later one is normally ignored and only one abort is taken.
;However, if the pending error was correctable, and the later one is not correctable, the pending error is ignored, and one abort is taken for the error
;that cannot be corrected.

;Memory barriers
;-----------------------------------
;When a store instruction, or series of instructions has been executed to normal-type or device-type memory, it is sometimes necessary to
;determine whether any errors occurred because of these instructions. Because most of these errors are reported imprecisely, they might not generate an
;abort exception until some time after the instructions are executed. To ensure that all possible errors have been reported,
;you must execute a DSB instruction. Abort exceptions are only taken because of these errors if they are not masked, that is, the CPSR A-bit is clear.
;If the A-bit is set, the aborts are held pending.


;Aborts in Strongly Ordered and Device memory
;-------------------------------------------
;When a memory access generates an abort, the instruction generating that access is abandoned, even if it has not completed all its memory accesses,
;and the abort exception is taken. The abort handler can then do one of the following:
;    fix the error and return to the instruction that was abandoned, to re-execute it
;    perform the appropriate data transfers on behalf of the aborted instruction and return to the instruction after the abandoned instruction
;    treat the error as fatal and terminate the process.

;If the abort handler returns to the abandoned instruction, some of the memory accesses generated are repeated.
;The effect is that multiword load/store instructions can access the same memory location twice. The first access occurs before the abort is detected,
;and the second when the instruction is restarted.

;In Strongly Ordered or Device type memory, repeating memory accesses might have unacceptable side-effects.
;Therefore, if the abort handler can fix the error and re-execute the aborted instruction, you must ensure that for all memory errors on
;multiword load/store instructions, either:
;    all side effects of repeating accesses are inconsequential
;    the error must either occur on the first word accessed or not at all.

;The instructions that this rule applies to are:
;    All forms of ARM instructions LDM, and LDRD, all forms of STM, STRD including VFP variants, and unaligned LDR, STR, LDRH, and STRH
;    Thumb instructions LDMIA, LDRD, SDRD, PUSH, POP, and STMIA including VFP variants, and unaligned LDR, STR, LDRH, and STRH.

;Abort handler
;----------------------------
;If you configure the processor with parity or ECC on the caches or the TCMs, and the abort handler is in one of these memories,
;then it is possible for a parity or ECC error to occur in the abort handler. If the error is not recoverable, then a precise abort occurs and the
;processor loops until the next interrupt. The LR and SPSR values for the original abort are also lost.
;Therefore, you must construct software that ensures that no precise aborts occur when in the abort handler.
;This means the abort handler must be in external memory and not cached.


    .text
    .arm


;-------------------------------------------------------------------------------
; Run Memory Test

    .ref	custom_dabort
    .def	_dabort
    .asmfunc

_dabort
		stmfd	r13!, {r0 - r12, lr}; push registers and link register on to stack

        ldr		r12, esmsr3			; ESM Group3 status register
        ldr		r0,  [r12]
        tst		r0,  #0x8			; check if bit 3 is set, this indicates uncorrectable ECC error on B0TCM
        bne		ramErrorFound
        tst		r0, #0x20			; check if bit 5 is set, this indicates uncorrectable ECC error on B1TCM
        bne		ramErrorFound2

noRAMerror
		tst		r0, #0x80			; check if bit 7 is set, this indicates uncorrectable ECC error on ATCM
		bne		flashErrorFound

;Checking the link register (r14) as described in your Keil link above will show you the instruction that triggered the data abort.

		bl		custom_dabort		; custom data abort handler required
									; If this custom handler is written in assembly, all registers used in the routine
									; and the link register must be saved on to the stack upon entry, and restored before
									; return from the routine.

		ldmfd	r13!, {r0 - r12, lr}; pop registers and link register from stack
		subs	pc, lr, #8			; restore state of CPU when abort occurred, and branch back to instruction that was aborted

ramErrorFound
		ldr		r1, ramctrl			; RAM control register for B0TCM TCRAMW
		ldr		r2, [r1]
		tst		r2, #0x100			; check if bit 8 is set in RAMCTRL, this indicates ECC memory write is enabled
		beq		ramErrorReal
		mov		r2, #0x20
		str		r2, [r1, #0x10]		; clear RAM error status register

		mov		r2, #0x08
		str		r2, [r12]			; clear ESM group3 channel3 flag for uncorrectable RAM ECC errors
		mov		r2, #5
		str		r2, [r12, #0x18]	; The nERROR pin will become inactive once the LTC counter expires

		ldmfd	r13!, {r0 - r12, lr}
		subs	pc, lr, #4			; branch to instruction after the one that caused the abort
									; this is the case because the data abort was caused intentionally
									; and we do not want to cause the same data abort again.

ramErrorFound2
		ldr		r1, ram2ctrl		; RAM control register for B1TCM TCRAMW
		ldr		r2, [r1]
		tst		r2, #0x100			; check if bit 8 is set in RAMCTRL, this indicates ECC memory write is enabled
		beq		ramErrorReal
		mov		r2, #0x20
		str		r2, [r1, #0x10]		; clear RAM error status register

		mov		r2, #0x20
		str		r2, [r12]			; clear ESM group3 flags channel5 flag for uncorrectable RAM ECC errors
		mov		r2, #5
		str		r2, [r12, #0x18]	; The nERROR pin will become inactive once the LTC counter expires

		ldmfd	r13!, {r0 - r12, lr}
		subs	pc, lr, #4			; branch to instruction after the one that caused the abort
									; this is the case because the data abort was caused intentionally
									; and we do not want to cause the same data abort again.


ramErrorReal
		b		ramErrorReal		; branch here forever as continuing operation is not recommended

flashErrorFound
		ldr		r1, flashbase
		ldr		r2, [r1, #0x6C]		; read FDIAGCTRL register

		mov     r2, r2, lsr #16
		tst		r2, #5				; check if bits 19:16 are 5, this indicates diagnostic mode is enabled
		beq		flashErrorReal
		mov		r2, #1
		mov     r2, r2, lsl #8		
		
		str		r2, [r1, #0x1C]		; clear FEDACSTATUS error flag

		mov		r2, #0x80
		str		r2, [r12]			; clear ESM group3 flag for uncorrectable flash ECC error
		mov		r2, #5
		str		r2, [r12, #0x18]	; The nERROR pin will become inactive once the LTC counter expires

		ldmfd	r13!, {r0 - r12, lr}
		subs	pc, lr, #4			; branch to instruction after the one that caused the abort
									; this is the case because the data abort was caused intentionally
									; and we do not want to cause the same data abort again.


flashErrorReal
		b		flashErrorReal		; branch here forever as continuing operation is not recommended
		
esmsr3		.word	0xFFFFF520
ramctrl		.word	0xFFFFF800
ram2ctrl	.word	0xFFFFF900
ram1errstat	.word	0xFFFFF810
ram2errstat	.word	0xFFFFF910
flashbase	.word	0xFFF87000

    .endasmfunc
	
	
